package com.example.concurrent.waitAndNotify;

import java.util.concurrent.ThreadLocalRandom;

/*
    Create by Atiye Mousavi 
    Date: 1/25/2022
    Time: 11:16 AM
**/
public class Sender implements Runnable{
//    اکنون که اصول اولیه را فهمیدیم، اجازه دهید از طریق یک برنامه فرستنده-گیرنده ساده که از متدهای wait() و notify() برای تنظیم همگام سازی بین آنها استفاده می کند، بپردازیم:
//
//فرستنده قرار است یک بسته داده را به گیرنده ارسال کند.
//گیرنده نمی تواند بسته داده را پردازش کند تا زمانی که فرستنده ارسال آن را تمام کند.
//به طور مشابه، فرستنده نباید اقدام به ارسال بسته دیگری کند، مگر اینکه گیرنده قبلا بسته قبلی را پردازش کرده باشد.




//    بیایید آنچه را که در اینجا می گذرد را تجزیه کنیم:
//
//متغیر packet نشان دهنده داده هایی است که از طریق شبکه منتقل می شوند.
//ما یک انتقال متغیر بولی داریم که فرستنده و گیرنده از آن برای همگام سازی استفاده می کنند:
//اگر این متغیر درست باشد، گیرنده باید منتظر بماند تا فرستنده پیام را ارسال کند.
//اگر نادرست است، فرستنده باید منتظر دریافت پیام باشد.
//فرستنده از متد send() برای ارسال داده به گیرنده استفاده می کند:
//اگر انتقال نادرست است، با فراخوانی wait() در این رشته منتظر می مانیم.
//اما وقتی درست باشد، وضعیت را تغییر می‌دهیم، پیام خود را تنظیم می‌کنیم و با notifyAll() تماس می‌گیریم تا رشته‌های دیگر بیدار شوند تا مشخص کنیم که یک رویداد مهم رخ داده است و آنها می‌توانند بررسی کنند که آیا می‌توانند به اجرا ادامه دهند یا خیر.
//به طور مشابه، گیرنده از متد ()receiver استفاده خواهد کرد:
//اگر انتقال توسط فرستنده روی false تنظیم شده باشد، تنها در این صورت ادامه می یابد، در غیر این صورت ما wait () را در این رشته فراخوانی می کنیم.
//وقتی شرط برآورده شد، وضعیت را تغییر می‌دهیم، به همه رشته‌های منتظر اطلاع می‌دهیم تا بیدار شوند و بسته داده‌ای که دریافت شده است را برمی‌گردانیم.


//    بیایید نگاهی دقیق تر به این فرستنده بیندازیم:
//
//ما در حال ایجاد برخی بسته های داده تصادفی هستیم که به صورت آرایه بسته[] در سراسر شبکه ارسال می شوند.
//برای هر بسته، ما فقط send() را فراخوانی می کنیم.
//سپس ما Thread.sleep() را با فاصله تصادفی فراخوانی می کنیم تا پردازش های سنگین سمت سرور را تقلید کنیم.
//در نهایت، بیایید گیرنده خود را پیاده سازی کنیم:
    private Data data;

    public Sender(Data data){
        this.data=data;
    }
    @Override
    public void run() {
        String packets[]={
                "First packet",
                "Second packet",
                "Third packet",
                "Fourth packet",
                "End"
        };
        for (String packet :packets){
            data.send(packet);

            try {
                Thread.sleep(ThreadLocalRandom.current().nextInt(1000,5000));
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                System.out.println("Thread Interrupted");
            }
        }
    }
}
