package com.example.concurrent.yield;

/**
 * created by Atiye Mousavi
 * Date: 2/5/2022
 * Time: 4:22 PM
 **/


public class ThreadYield {
//    همانطور که اسناد رسمی نشان می دهد، yield() مکانیزمی را برای اطلاع دادن به "زمانبندی" ارائه می دهد که رشته فعلی مایل است استفاده فعلی خود از پردازنده را رها کند، اما مایل است هر چه زودتر برنامه ریزی شود.
//
//«زمان‌بند» آزاد است که به این اطلاعات پایبند باشد یا نادیده بگیرد و در واقع، بسته به سیستم عامل، رفتارهای متفاوتی دارد.
//
//قطعه کد زیر دو رشته را با اولویت یکسان پس از هر زمان‌بندی نمایش می‌دهد:
//    هنگامی که سعی می کنیم برنامه فوق را چندین بار اجرا کنیم، نتایج متفاوتی دریافت می کنیم.
//بنابراین همانطور که می بینید رفتار yield() غیر قطعی است و همچنین وابسته به پلتفرم است.


//3.1. yield() vs wait()
//    در حالی که yield() در زمینه رشته فعلی فراخوانی می شود، wait() فقط می تواند در یک قفل به طور صریح به دست آمده در داخل یک بلوک یا متد هماهنگ فراخوانی شود.
//برخلاف yield()، این امکان برای wait() وجود دارد که قبل از هر تلاشی برای زمان‌بندی مجدد رشته، حداقل مدت زمان انتظار را مشخص کند.
//با Wait() همچنین می توان هر زمان که خواستید thread را از طریق فراخوانی notify() یا notifyAll() روی شی lock مربوطه بیدار کرد.

//    3.2. yield() vs sleep()
//    در حالی که yield() تنها می تواند یک تلاش اکتشافی برای تعلیق اجرای thread فعلی انجام دهد بدون اینکه تضمینی در مورد زمان بندی مجدد آن وجود داشته باشد، sleep() می تواند زمانبندی را مجبور کند که اجرای thread فعلی را حداقل برای زمان ذکر شده به حالت تعلیق درآورد. دوره به عنوان پارامتر آن

//    3.3. yield() vs join()
//    thread فعلی می تواند join() را در هر رشته دیگری فراخوانی کند که باعث می شود thread فعلی منتظر بماند تا thread دیگر قبل از ادامه کار بمیرد.
//در صورت تمایل می‌تواند یک دوره زمانی را به عنوان پارامتر خود ذکر کند که نشان‌دهنده حداکثر زمانی است که رشته فعلی باید قبل از شروع مجدد منتظر بماند.

//    همانطور که اسناد رسمی نشان می دهد به ندرت استفاده از yield() ضروری است و از این رو باید از آن اجتناب شود مگر اینکه با توجه به رفتار آن اهداف کاملاً واضح باشد.
//
//با این وجود، برخی از کاربردهای yield() شامل طراحی ساختارهای کنترل همزمان، بهبود پاسخگویی سیستم در یک برنامه محاسباتی سنگین و غیره است.
//
//با این حال، این استفاده ها باید با مشخصات دقیق و محک زدن همراه باشد تا از نتیجه مطلوب اطمینان حاصل شود.

    public static void main(String[] args) {
        Runnable r=()->{
            int counter=0;
            while(counter < 2){
                System.out.println(Thread.currentThread().getName());
                counter++;
                Thread.yield();
            }
        };
        new Thread(r).start();
        new Thread(r).start();

    }
}
