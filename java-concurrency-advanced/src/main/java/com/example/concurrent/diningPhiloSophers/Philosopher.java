package com.example.concurrent.diningPhiloSophers;

/*
    Create by Atiye Mousavi 
    Date: 1/31/2022
    Time: 10:05 AM
**/
public class Philosopher implements Runnable {
//    نمودار بالا نشان دهنده مشکل است. پنج فیلسوف ساکت (P1 – P5) دور یک میز دایره ای نشسته اند و زندگی خود را صرف خوردن و فکر کردن می کنند.
//
//پنج چنگال برای آنها وجود دارد که آنها را با هم تقسیم کنند (1 تا 5) و برای اینکه یک فیلسوف بتواند بخورد، باید چنگال در هر دو دست داشته باشد. پس از خوردن غذا، هر دوی آنها را زمین می گذارد و سپس توسط فیلسوف دیگری که همان چرخه را تکرار می کند، انتخاب می شود.
//    همانطور که شبه کد بالا توضیح می دهد، هر فیلسوف در ابتدا در حال تفکر است. پس از مدتی، فیلسوف گرسنه می شود و آرزو می کند که غذا بخورد.
//
//در این مرحله، دستش را به چنگال های طرفین خود می برد و هنگامی که هر دوی آنها را بدست آورد، شروع به خوردن می کند. وقتی غذا خوردن تمام شد، فیلسوف چنگال ها را پایین می گذارد تا برای همسایه اش در دسترس باشد.

//    ما هر یک از فیلسوفان خود را به عنوان کلاس هایی مدل می کنیم که رابط Runnable را پیاده سازی می کنند تا بتوانیم آنها را به عنوان رشته های جداگانه اجرا کنیم. هر فیلسوف به دو چنگال در سمت چپ و راست خود دسترسی دارد:
//    ما همچنین روشی داریم که به فیلسوف دستور می دهد تا عملی را انجام دهد - بخورد، فکر کند، یا چنگال به دست آورد تا برای غذا خوردن آماده شود:
//    همانطور که در کد بالا نشان داده شده است، هر عمل با تعلیق رشته فراخوانی برای مدت زمان تصادفی شبیه سازی می شود، به طوری که دستور اجرا تنها با زمان اجرا نمی شود.
//    همانطور که در کد بالا نشان داده شده است، هر عمل با تعلیق رشته فراخوانی برای مدت زمان تصادفی شبیه سازی می شود، به طوری که دستور اجرا تنها با زمان اجرا نمی شود.
//
//حالا بیایید منطق اصلی یک فیلسوف را پیاده کنیم.
//
//برای شبیه سازی به دست آوردن یک چنگال، باید آن را قفل کنیم تا هیچ دو رشته فیلسوفی آن را همزمان به دست نیاورند.
//
//برای رسیدن به این هدف، از کلمه کلیدی همگام‌سازی شده استفاده می‌کنیم تا مانیتور داخلی شی فورک را بدست آوریم و از انجام این کار توسط رشته‌های دیگر جلوگیری کنیم. راهنمای کلمه کلیدی همگام سازی شده در جاوا را می توانید در اینجا بیابید. اکنون به پیاده سازی متد run() در کلاس Philosopher ادامه می دهیم:
//    این طرح دقیقاً همان طرحی را که قبلا توضیح داده شد اجرا می کند: یک فیلسوف مدتی فکر می کند و سپس تصمیم می گیرد غذا بخورد.
//
//پس از این، چنگال های چپ و راست خود را می گیرد و شروع به خوردن می کند. پس از اتمام کار، چنگال ها را پایین می گذارد. ما همچنین به هر عمل مهر زمانی اضافه می کنیم که به ما کمک می کند ترتیب وقوع رویدادها را درک کنیم.
//
//برای شروع کل فرآیند، مشتری می نویسیم که 5 فیلسوف را به عنوان نخ ایجاد می کند و همه آنها را شروع می کند:
//    همه فیلسوفان در ابتدا شروع به فکر کردن می‌کنند، و می‌بینیم که فیلسوف 1 چنگال چپ و راست را برمی‌دارد، سپس می‌خورد و هر دو را پایین می‌گذارد، پس از آن «فیلسوف 5» آن را برمی‌دارد.
//    اگرچه به نظر می رسد که راه حل فوق صحیح است، اما یک مسئله بن بست وجود دارد.
//
//بن بست وضعیتی است که در آن پیشرفت یک سیستم متوقف می شود زیرا هر فرآیند منتظر به دست آوردن منبعی است که توسط یک فرآیند دیگر نگهداری می شود.
//    می‌توانیم با اجرای چند بار کد بالا و بررسی اینکه برخی اوقات، کد فقط هنگ می‌کند، همین را تأیید کنیم. در اینجا یک نمونه خروجی وجود دارد که مشکل فوق را نشان می دهد:
//    در این شرایط، هر یک از فیلسوفان چنگال چپ خود را به دست آورده است، اما نمی تواند چنگال راست خود را بدست آورد، زیرا همسایه او قبلاً آن را به دست آورده است. این وضعیت معمولاً به عنوان انتظار دایره ای شناخته می شود و یکی از شرایطی است که منجر به بن بست می شود و از پیشرفت سیستم جلوگیری می کند.
//    همانطور که در بالا دیدیم، دلیل اصلی بن بست، شرایط انتظار دایره ای است که در آن هر فرآیند روی منبعی منتظر می ماند که توسط یک فرآیند دیگر نگهداری می شود. بنابراین، برای جلوگیری از یک وضعیت بن‌بست، باید مطمئن شویم که شرط انتظار دایره‌ای شکسته شده است. راه های مختلفی برای رسیدن به این هدف وجود دارد که ساده ترین آنها به شرح زیر است:
//
//همه فیلسوفان ابتدا به دوشاخه چپ خود می رسند، به جز کسی که ابتدا دستش را به چنگال راست خود می رساند.
//
//ما این را در کد موجود خود با ایجاد یک تغییر نسبتاً جزئی در کد پیاده سازی می کنیم:
//    این تغییر در خطوط 17-19 کد بالا آمده است، جایی که شرایطی را معرفی می‌کنیم که باعث می‌شود آخرین فیلسوف به جای چپ، ابتدا به چنگال راست خود برسد. این شرایط انتظار دایره ای را می شکند و می توانیم از بن بست جلوگیری کنیم.
//

    private final Object leftFork;
    private final Object rightFork;

    public Philosopher(Object leftFork, Object rightFork) {
        this.leftFork = leftFork;
        this.rightFork = rightFork;
    }

    private void doAction(String action) throws InterruptedException {
        System.out.println(Thread.currentThread().getName() + " " + action);
        Thread.sleep((int) (Math.random() * 100));
    }

    @Override
    public void run() {
        try {
            while (true) {
                doAction(System.nanoTime() + ": Thinking");
                synchronized (leftFork) {
                    doAction(System.nanoTime() + ": Picked up left fork");
                    synchronized (rightFork){
                        doAction(System.nanoTime() + ": Picked up right fork -eating");
                        doAction(System.nanoTime() + ": Put down right fork");
                    }
                    doAction(System.nanoTime() +": Put down left fork.Returning to thinking");
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

}

