package com.example.concurrent.volatileKeyWord;

/*
    Create by Atiye Mousavi 
    Date: 2/1/2022
    Time: 9:19 AM
**/
public class TaskRunner {
//    کلاس TaskRunner دو متغیر ساده را حفظ می کند. در روش اصلی خود، رشته دیگری ایجاد می کند که تا زمانی که متغیر آماده باشد، آن غلط است. وقتی متغیر درست شد، رشته به سادگی متغیر عدد را چاپ می کند.
//    بسیاری ممکن است انتظار داشته باشند که این برنامه پس از یک تاخیر کوتاه به سادگی 42 را چاپ کند. با این حال، در واقعیت، تاخیر ممکن است بسیار طولانی تر باشد. حتی ممکن است برای همیشه آویزان شود، یا حتی صفر چاپ شود!
//
//علت این ناهنجاری ها عدم مشاهده مناسب حافظه و ترتیب مجدد است. بیایید آنها را با جزئیات بیشتر ارزیابی کنیم.

//    در این مثال ساده، ما دو رشته کاربردی داریم: رشته اصلی و موضوع خواننده. بیایید سناریویی را تصور کنیم که در آن سیستم‌عامل آن رشته‌ها را روی دو هسته CPU مختلف زمان‌بندی می‌کند، که در آن:
//
//رشته اصلی کپی از متغیرهای آماده و تعداد را در حافظه پنهان اصلی خود دارد
//تاپیک خواننده نیز با نسخه های آن به پایان می رسد
//رشته اصلی مقادیر ذخیره شده را به روز می کند
//در اکثر پردازنده‌های مدرن، درخواست‌های نوشتن بلافاصله پس از صدور اعمال نمی‌شوند. در واقع، پردازنده‌ها تمایل دارند آن نوشته‌ها را در یک بافر مخصوص نوشتن در صف قرار دهند. پس از مدتی، آن ها را به یکباره روی حافظه اصلی اعمال می کنند.
//
//با تمام آنچه گفته شد، زمانی که رشته اصلی تعداد و متغیرهای آماده را به روز می کند، هیچ تضمینی در مورد آنچه موضوع خواننده ممکن است ببیند وجود ندارد. به عبارت دیگر، نخ خواننده ممکن است مقدار به روز شده را فوراً یا با کمی تأخیر یا اصلاً مشاهده نکند!
//
//این قابلیت رویت حافظه ممکن است باعث ایجاد مشکلات زنده‌گی در برنامه‌هایی شود که به دید متکی هستند.

//    بدتر از این که موضوع خواننده ممکن است این نوشته ها را به ترتیبی غیر از ترتیب واقعی برنامه ببیند. به عنوان مثال، از آنجایی که ابتدا متغیر عدد را به روز می کنیم:
//
//
//ممکن است انتظار داشته باشیم که ریدر چاپ 42 باشد. با این حال، در واقع ممکن است صفر را به عنوان مقدار چاپ شده مشاهده کنیم!
//
//ترتیب مجدد یک تکنیک بهینه سازی برای بهبود عملکرد است. جالب توجه است که اجزای مختلف ممکن است این بهینه سازی را اعمال کنند:
//
//پردازنده ممکن است بافر نوشتن خود را به هر ترتیبی غیر از ترتیب برنامه شستشو دهد
//پردازنده ممکن است تکنیک اجرای خارج از نظم را اعمال کند
//کامپایلر JIT ممکن است از طریق مرتب سازی مجدد بهینه شود

//    برای اطمینان از اینکه به‌روزرسانی‌های متغیرها به‌طور قابل پیش‌بینی در رشته‌های دیگر منتشر می‌شوند، باید اصلاحگر فرار را روی آن متغیرها اعمال کنیم:
//
//
//به این ترتیب، ما با زمان اجرا و پردازنده ارتباط برقرار می کنیم تا هیچ دستوری که شامل متغیر فرار است را تغییر ندهیم. همچنین، پردازنده ها می دانند که باید هر گونه به روز رسانی این متغیرها را فوراً پاک کنند.
//    برای برنامه های چند رشته ای، باید از چند قانون برای رفتار ثابت اطمینان حاصل کنیم:
//
//Mutual Exclusion - فقط یک رشته یک بخش مهم را در یک زمان اجرا می کند
//Visibility  - تغییرات ایجاد شده توسط یک رشته در داده های مشترک برای سایر رشته ها قابل مشاهده است تا یکنواختی داده ها حفظ شود.
//روش‌ها و بلوک‌های همگام‌سازی شده هر دو ویژگی فوق را به قیمت عملکرد برنامه ارائه می‌کنند.
//
//فرار یک کلمه کلیدی کاملا مفید است زیرا می تواند به اطمینان از نمایان بودن تغییر داده ها کمک کند، البته بدون استثناء متقابل. بنابراین، در جاهایی که ما مشکلی نداریم با چندین رشته که یک بلوک کد را به صورت موازی اجرا می‌کنند، مفید است، اما باید از ویژگی visibility اطمینان حاصل کنیم.
//    اثرات قابل مشاهده بودن حافظه متغیرهای فرار فراتر از خود متغیرهای فرار است.
//
//برای ملموس‌تر کردن موضوع، فرض کنیم رشته A روی یک متغیر فرار می‌نویسد، و سپس رشته B همان متغیر فرار را می‌خواند. در چنین مواردی، مقادیری که قبل از نوشتن متغیر فرار برای A قابل مشاهده بودند، پس از خواندن متغیر فرار برای B قابل مشاهده خواهند بود:

//    از نظر فنی، هر گونه نوشتن در یک فیلد فرار قبل از هر خواندن بعدی همان فیلد اتفاق می افتد. این قانون متغیر فرار مدل حافظه جاوا (JMM) است.

    private static int number;
    private volatile static boolean ready;

    private static class Reader extends Thread{
        @Override
        public void run() {
            while(!ready){
                Thread.yield();
            }
            System.out.println(number);
        }
    }

    public static void main(String[] args) {
        new Reader().start();
        number=42;
        ready=true;
    }
}
