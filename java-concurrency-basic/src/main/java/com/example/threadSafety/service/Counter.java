package com.example.threadSafety.service;

/*
    Create by Atiye Mousavi 
    Date: 1/18/2022
    Time: 12:17 PM
**/
public class Counter {
//    روش‌ها و بلوک‌های همگام‌سازی شده برای رسیدگی به مشکلات دید متغیر در بین رشته‌ها مفید هستند. حتی در این صورت، مقادیر فیلدهای کلاس معمولی ممکن است توسط CPU ذخیره شوند. بنابراین، به‌روزرسانی‌های بعدی برای یک فیلد خاص، حتی اگر همگام‌سازی شوند، ممکن است برای رشته‌های دیگر قابل مشاهده نباشند.
//
//برای جلوگیری از این وضعیت، می توانیم از فیلدهای کلاس فرار استفاده کنیم:
//
//با کلمه کلیدی فرار، به JVM و کامپایلر دستور می دهیم که متغیر شمارنده را در حافظه اصلی ذخیره کنند. به این ترتیب، ما مطمئن می‌شویم که هر بار که JVM مقدار متغیر شمارنده را می‌خواند، به‌جای اینکه از حافظه نهان CPU استفاده کند، در واقع آن را از حافظه اصلی بخواند. به همین ترتیب، هر بار که JVM روی متغیر شمارنده می نویسد، مقدار آن در حافظه اصلی نوشته می شود.
//
//علاوه بر این، استفاده از یک متغیر فرار تضمین می کند که تمام متغیرهایی که برای یک رشته مشخص قابل مشاهده هستند، از حافظه اصلی نیز خوانده می شوند.
//

//    در این حالت، هر بار که JVM متغیر سنی فرار را در حافظه اصلی می نویسد، متغیر نام غیر فرار را نیز در حافظه اصلی می نویسد. این اطمینان می دهد که آخرین مقادیر هر دو متغیر در حافظه اصلی ذخیره می شود، بنابراین به روز رسانی های متعاقب متغیرها به طور خودکار برای رشته های دیگر قابل مشاهده خواهد بود.
//
//به طور مشابه، اگر یک رشته مقدار یک متغیر فرار را بخواند، تمام متغیرهای قابل مشاهده برای رشته از حافظه اصلی نیز خوانده می‌شوند.
//
//این ضمانت توسعه یافته که متغیرهای فرار ارائه می کنند به عنوان ضمانت دید کامل فرار شناخته می شود.
    private volatile int counter;

    public Counter() {
        this.counter = 0;
    }

    public synchronized void incrementCounter() {
        counter += 1;
    }

    public int getCounter() {
        return counter;
    }
}
